/**
 * Cloudflare Worker for Fieldawy Store Notifications
 * Receives webhooks from Supabase and sends FCM notifications
 */

export default {
  async fetch(request, env) {
    // CORS Headers
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    };

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    // Only accept POST requests
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { 
        status: 405,
        headers: corsHeaders 
      });
    }

    try {
      const payload = await request.json();
      
      console.log('ðŸ“© Received webhook from Supabase');
      console.log('   Type:', payload.type);
      console.log('   Table:', payload.table);

      // Extract data
      const { type: operation, table, record, old_record } = payload;
      
      if (!record) {
        return new Response('No record in payload', { 
          status: 400,
          headers: corsHeaders 
        });
      }

      // Get product name and details
      let productName = 'Ù…Ù†ØªØ¬';
      let tabName = 'home';
      let isPriceUpdate = false;

      // Process based on table
      if (table === 'distributor_surgical_tools' || table === 'surgical_tools') {
        productName = record.tool_name || record.description || 'Ø£Ø¯Ø§Ø© Ø¬Ø±Ø§Ø­ÙŠØ©';
        tabName = 'surgical';
        
        if (operation === 'UPDATE' && old_record && old_record.price !== record.price) {
          tabName = 'price_action';
          isPriceUpdate = true;
        }
      } else if (table === 'offers') {
        if (operation === 'INSERT' && !record.description) {
          console.log('â­ï¸ Skipping offer without description');
          return new Response('Skipped', { status: 200, headers: corsHeaders });
        }

        if (record.product_id && env.SUPABASE_URL && env.SUPABASE_SERVICE_KEY) {
          try {
            const tableName = record.is_ocr ? 'ocr_products' : 'products';
            const columnName = record.is_ocr ? 'product_name' : 'name';
            
            const response = await fetch(
              `${env.SUPABASE_URL}/rest/v1/${tableName}?id=eq.${record.product_id}&select=${columnName}`,
              {
                headers: {
                  'apikey': env.SUPABASE_SERVICE_KEY,
                  'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,
                }
              }
            );
            
            const data = await response.json();
            if (data && data[0]) {
              productName = `${data[0][columnName]} - ${record.description || 'Ø¹Ø±Ø¶'}`;
            } else {
              productName = record.description || 'Ø¹Ø±Ø¶';
            }
          } catch (err) {
            productName = record.description || 'Ø¹Ø±Ø¶';
          }
        } else {
          productName = record.description || 'Ø¹Ø±Ø¶';
        }
        
        if (operation === 'UPDATE' && old_record && old_record.price !== record.price) {
          tabName = 'price_action';
          isPriceUpdate = true;
        } else {
          tabName = 'offers';
        }
      } else if (table === 'distributor_products' || table === 'distributor_ocr_products') {
        if (env.SUPABASE_URL && env.SUPABASE_SERVICE_KEY) {
          try {
            let prodName = 'Ù…Ù†ØªØ¬';
            if (table === 'distributor_products' && record.product_id) {
              const prodResponse = await fetch(
                `${env.SUPABASE_URL}/rest/v1/products?id=eq.${record.product_id}&select=name`,
                {
                  headers: {
                    'apikey': env.SUPABASE_SERVICE_KEY,
                    'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,
                  }
                }
              );
              const prodData = await prodResponse.json();
              if (prodData && prodData[0]) prodName = prodData[0].name;
            } else if (table === 'distributor_ocr_products' && record.ocr_product_id) {
              const prodResponse = await fetch(
                `${env.SUPABASE_URL}/rest/v1/ocr_products?id=eq.${record.ocr_product_id}&select=product_name`,
                {
                  headers: {
                    'apikey': env.SUPABASE_SERVICE_KEY,
                    'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,
                  }
                }
              );
              const prodData = await prodResponse.json();
              if (prodData && prodData[0]) prodName = prodData[0].product_name;
            }
            
            let distributorName = '';
            if (record.distributor_id) {
              const userResponse = await fetch(
                `${env.SUPABASE_URL}/rest/v1/users?id=eq.${record.distributor_id}&select=full_name,username`,
                {
                  headers: {
                    'apikey': env.SUPABASE_SERVICE_KEY,
                    'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,
                  }
                }
              );
              const userData = await userResponse.json();
              if (userData && userData[0]) {
                distributorName = userData[0].full_name || userData[0].username || '';
              }
            }
            
            productName = distributorName ? `${prodName} - ${distributorName}` : prodName;
          } catch (err) {
            productName = 'Ù…Ù†ØªØ¬';
          }
        }
        
        let isExpiringSoon = false;
        let expirationDate = record.expiration_date;
        
        if (!expirationDate && record.id && env.SUPABASE_URL && env.SUPABASE_SERVICE_KEY) {
          try {
            const response = await fetch(
              `${env.SUPABASE_URL}/rest/v1/${table}?id=eq.${record.id}&select=expiration_date`,
              {
                headers: {
                  'apikey': env.SUPABASE_SERVICE_KEY,
                  'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,
                }
              }
            );
            const data = await response.json();
            if (data && data[0]) expirationDate = data[0].expiration_date;
          } catch (err) {
            console.error('Error fetching expiration_date:', err);
          }
        }
        
        if (expirationDate) {
          const expDate = new Date(expirationDate);
          const now = new Date();
          const days = (expDate - now) / (1000 * 60 * 60 * 24);
          if (days > 0 && days <= 365) {
            isExpiringSoon = true;
          }
        }
        
        if (operation === 'UPDATE') {
          if (old_record && old_record.price !== record.price) {
            isPriceUpdate = true;
            tabName = isExpiringSoon ? 'expire_soon_price' : 'price_action';
          } else if (isExpiringSoon) {
            tabName = 'expire_soon_update';
          }
        } else if (isExpiringSoon) {
          tabName = 'expire_soon';
        }
        
        if (operation === 'INSERT' && tabName === 'home') {
          console.log('â­ï¸ Skipping regular product insert');
          return new Response('Skipped', { status: 200, headers: corsHeaders });
        }
      }

      console.log('   Product Name:', productName);
      console.log('   Tab Name:', tabName);

      // Build notification
      const isNew = operation === 'INSERT';
      let title = '';
      let body = '';
      let screen = '';

      if (tabName === 'surgical') {
        title = isNew ? 'ðŸ”§ Ø£Ø¯Ø§Ø© Ø¬Ø¯ÙŠØ¯Ø©' : 'ðŸ”§ ØªØ­Ø¯ÙŠØ« Ø£Ø¯Ø§Ø©';
        body = productName;
        screen = 'surgical';
      } else if (tabName === 'offers') {
        title = 'ðŸŽ Ø¹Ø±Ø¶ Ø¬Ø¯ÙŠØ¯';
        body = productName;
        screen = 'offers';
      } else if (tabName === 'expire_soon') {
        let daysLeft = '';
        if (record.expiration_date) {
          const expDate = new Date(record.expiration_date);
          const now = new Date();
          const days = Math.ceil((expDate - now) / (1000 * 60 * 60 * 24));
          daysLeft = ` - ÙŠÙ†ØªÙ‡ÙŠ Ø®Ù„Ø§Ù„ ${days} ÙŠÙˆÙ…`;
        }
        title = 'âš ï¸ ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ù‚Ø±ÙŠØ¨ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©';
        body = `${productName}${daysLeft}`;
        screen = 'expire_soon';
      } else if (tabName === 'expire_soon_price') {
        title = 'ðŸ’°âš ï¸ ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ù…Ù†ØªØ¬ Ø¹Ù„Ù‰ ÙˆØ´Ùƒ Ø§Ù†ØªÙ‡Ø§Ø¡ ØµÙ„Ø§Ø­ÙŠØªÙ‡';
        body = productName;
        screen = 'price_action';
      } else if (tabName === 'expire_soon_update') {
        title = 'ðŸ”„âš ï¸ ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ù†ØªØ¬ ØªÙ†ØªÙ‡ÙŠ ØµÙ„Ø§Ø­ÙŠØªÙ‡ Ù‚Ø±ÙŠØ¨Ø§Ù‹';
        body = productName;
        screen = 'expire_soon';
      } else if (tabName === 'price_action') {
        if (table === 'distributor_surgical_tools') {
          title = 'ðŸ’° ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø£Ø¯Ø§Ø©';
        } else if (table === 'offers') {
          title = 'ðŸ’° ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ø¹Ø±Ø¶';
        } else {
          title = 'ðŸ’° ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± Ù…Ù†ØªØ¬';
        }
        body = productName;
        screen = 'price_action';
      } else {
        title = isNew ? 'âœ… Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯' : 'ðŸ”„ ØªØ­Ø¯ÙŠØ« Ù…Ù†ØªØ¬';
        body = productName;
        screen = 'home';
      }

      // Send FCM notification
      if (!env.FIREBASE_SERVICE_ACCOUNT) {
        throw new Error('FIREBASE_SERVICE_ACCOUNT not configured');
      }

      const serviceAccount = JSON.parse(env.FIREBASE_SERVICE_ACCOUNT);
      const accessToken = await getAccessToken(serviceAccount);

      const fcmUrl = `https://fcm.googleapis.com/v1/projects/${serviceAccount.project_id}/messages:send`;
      
      const message = {
        message: {
          topic: 'all_users',
          data: {
            title: title,
            body: body,
            type: 'product_update',
            screen: screen,
          },
          android: {
            priority: 'high',
          },
        }
      };

      const fcmResponse = await fetch(fcmUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`,
        },
        body: JSON.stringify(message),
      });

      if (!fcmResponse.ok) {
        const error = await fcmResponse.text();
        throw new Error(`FCM Error: ${error}`);
      }

      console.log('âœ… Notification sent!');
      console.log('   Title:', title);

      return new Response('Notification sent', {
        status: 200,
        headers: corsHeaders
      });

    } catch (error) {
      console.error('âŒ Error:', error);
      return new Response(`Error: ${error.message}`, {
        status: 500,
        headers: corsHeaders
      });
    }
  },
};

// Get Firebase access token using JWT
async function getAccessToken(serviceAccount) {
  const now = Math.floor(Date.now() / 1000);
  
  const header = {
    alg: 'RS256',
    typ: 'JWT'
  };
  
  const claimSet = {
    iss: serviceAccount.client_email,
    scope: 'https://www.googleapis.com/auth/firebase.messaging',
    aud: 'https://oauth2.googleapis.com/token',
    exp: now + 3600,
    iat: now,
  };
  
  const encodedHeader = base64UrlEncode(JSON.stringify(header));
  const encodedClaimSet = base64UrlEncode(JSON.stringify(claimSet));
  const signatureInput = `${encodedHeader}.${encodedClaimSet}`;
  
  const privateKey = await importPrivateKey(serviceAccount.private_key);
  
  const signature = await crypto.subtle.sign(
    { name: 'RSASSA-PKCS1-v1_5' },
    privateKey,
    new TextEncoder().encode(signatureInput)
  );
  
  const encodedSignature = base64UrlEncode(signature);
  const jwt = `${signatureInput}.${encodedSignature}`;
  
  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`,
  });
  
  const data = await response.json();
  return data.access_token;
}

async function importPrivateKey(pem) {
  const pemContents = pem
    .replace('-----BEGIN PRIVATE KEY-----', '')
    .replace('-----END PRIVATE KEY-----', '')
    .replace(/\s/g, '');
  
  const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
  
  return await crypto.subtle.importKey(
    'pkcs8',
    binaryDer,
    { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
    false,
    ['sign']
  );
}

function base64UrlEncode(data) {
  if (data instanceof ArrayBuffer) {
    data = String.fromCharCode(...new Uint8Array(data));
  }
  return btoa(data)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
